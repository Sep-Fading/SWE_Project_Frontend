// middleware.ts
import { NextRequest, NextResponse } from "next/server";

async function validateSession(accessToken: string) {
  try {
    const response = await fetch(`${process.env.BACKEND_URL}/accounts/api/validate_session/`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
      credentials: "include",
    });
    if (!response.ok) throw new Error("Session validation failed");
    const data = await response.json();
    return { valid: true, role: data.userRole };
  } catch (error) {
    return { valid: false };
  }
}

export async function middleware(request: NextRequest) {
  const loginPath = '/Login';

  // Retrieve access token from cookies.
  const accessToken = request.cookies.get("access_token");

  if (accessToken) {
    const { valid, role } = await validateSession(accessToken);
    if (valid && role) {
      // Use the validated role for redirection logic
      if (request.nextUrl.pathname.startsWith(loginPath)) {
        return NextResponse.redirect(new URL(`/${role}/user_page`, request.url));
      }

      if (request.nextUrl.pathname.startsWith(`/${role}`)) {
        return NextResponse.next();
      }

      // Redirect to the role-specific page if not on an allowed path.
      return NextResponse.redirect(new URL(`/${role}`, request.url));
    }
  }

  // Redirect unauthenticated requests to the login page, excluding API paths.
  if (!accessToken && !request.nextUrl.pathname.startsWith(loginPath) &&
    !request.nextUrl.pathname.startsWith('/api')) {
    return NextResponse.redirect(new URL(loginPath, request.url));
  }

  // Continue with the request if none of the above conditions are met.
  return NextResponse.next();
}

export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico).*)',
  ],
};

